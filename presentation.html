<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tussi - Distributed E-commerce Platform</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/monokai.css">
    <style>
        :root {
            --r-main-color: #ffffff;
            --r-heading-color: #ff1493;
            --r-background-color: #000000;
            --r-link-color: #ff69b4;
            --r-selection-background-color: #ff1493;
            --r-main-font-size: 32px;
        }

        .reveal {
            font-size: 28px;
        }

        .reveal h3 {
            font-size: 1.8em;
            color: #ff1493;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255, 20, 147, 0.3);
        }

        .reveal p,
        .reveal li {
            font-size: 0.85em;
            line-height: 1.3;
        }

        .reveal .slides section .fragment {
            color: #ffffff;
        }

        .reveal .progress {
            color: #ff1493;
        }

        .small-text {
            font-size: 0.75em;
        }

        .smaller-text {
            font-size: 0.65em;
        }

        .tiny-text {
            font-size: 0.55em;
        }

        .team-member {
            display: inline-block;
            margin: 15px;
            padding: 20px;
            border: 2px solid #ff1493;
            border-radius: 15px;
            background: linear-gradient(45deg, rgba(255, 20, 147, 0.1), rgba(255, 105, 180, 0.1));
            transition: transform 0.3s ease;
        }

        .team-member:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.5);
        }

        .architecture-diagram {
            max-width: 90%;
            max-height: 70vh;
            border: 3px solid #ff1493;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.3);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.8em;
        }

        .data-table th,
        .data-table td {
            border: 2px solid #ff1493;
            padding: 10px;
            text-align: left;
        }

        .data-table th {
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.3), rgba(255, 105, 180, 0.2));
            font-weight: bold;
        }

        .data-table tr:hover {
            background: rgba(255, 20, 147, 0.1);
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title -->
            <section>
                <img src="logo.png" alt="Tussi Logo" style="max-width: 300px;">
                <h3>TUSSI</h3>
                <p>Distributed E-commerce Platform</p>
            </section>

            <section>
                <div class="team-member">
                    <p>Xamir Ernesto Rojas Gamboa</p>
                </div>
                <div class="team-member">
                    <p>Juan Sebastian Medina Pinto</p>
                </div>
                <div class="team-member">
                    <p>Juan Manuel Pérez Ordoñez</p>
                </div>
            </section>

            <section>
                <h3>Description</h3>
                <p>Tussi is a distributed e-commerce platform built with modern microservices architecture that provides
                    user authentication, product catalog management, and shopping cart functionality. The system is
                    designed to handle high traffic loads through distributed services and uses modern web technologies
                    for optimal performance and scalability.</p>
            </section>
            <!-- Architectural Structure -->
            <section>
                <h3>3. Architectural Structure</h3>
                <p>A comprehensive view of system architecture through multiple perspectives.</p>
            </section>

            <section>
                <h3>Component-and-Connector View</h3>
                <p>A system comprising two clients, a load balancer, four services, and three databases, connected by
                    ten connectors.</p>
            </section>

            <section>
                <img src="c&c-h.png" alt="C&C Architecture" class="architecture-diagram">
            </section>

            <section>
                <h3>Components</h3>
                <table class="data-table">
                    <tr>
                        <th>Component</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Web Client</td>
                        <td>Next.js/React app in browser</td>
                    </tr>
                    <tr>
                        <td>Mobile Client</td>
                        <td>React Native on iOS/Android</td>
                    </tr>
                    <tr>
                        <td>Load Balancer</td>
                        <td>Nginx with SSL termination, round-robin distribution</td>
                    </tr>
                    <tr>
                        <td>API Gateway</td>
                        <td>JWT, rate limiting, CORS, logging and health checks (4 replicas)</td>
                    </tr>
                    <tr>
                        <td>Auth Service</td>
                        <td>FastAPI (Python) with endpoints for register, login, me</td>
                    </tr>
                    <tr>
                        <td>Products API</td>
                        <td>FastAPI (Python) with endpoints for products listing and details</td>
                    </tr>
                    <tr>
                        <td>Cart API</td>
                        <td>Node.js/Express with cart operations endpoints</td>
                    </tr>
                    <tr>
                        <td>Auth Database</td>
                        <td>PostgreSQL on port 5432 for credentials and user data</td>
                    </tr>
                    <tr>
                        <td>Products Database</td>
                        <td>PostgreSQL on port 5433 for catalog and inventory</td>
                    </tr>
                    <tr>
                        <td>Cart Database</td>
                        <td>MongoDB on port 27017 for sessions and cart data</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Connectors</h3>
                <table class="data-table">
                    <tr>
                        <th>Connector</th>
                        <th>Type</th>
                        <th>From</th>
                        <th>To</th>
                    </tr>
                    <tr>
                        <td>c1</td>
                        <td>HTTPS/HTTP</td>
                        <td>Web Client</td>
                        <td>Load Balancer</td>
                    </tr>
                    <tr>
                        <td>c2</td>
                        <td>HTTPS/HTTP</td>
                        <td>Mobile Client</td>
                        <td>Load Balancer</td>
                    </tr>
                    <tr>
                        <td>c3</td>
                        <td>HTTP (Load Balancing)</td>
                        <td>Load Balancer</td>
                        <td>API Gateway</td>
                    </tr>
                    <tr>
                        <td>c4</td>
                        <td>HTTP (REST)</td>
                        <td>API Gateway</td>
                        <td>Auth Service</td>
                    </tr>
                    <tr>
                        <td>c5</td>
                        <td>HTTP (REST)</td>
                        <td>API Gateway</td>
                        <td>Products API</td>
                    </tr>
                    <tr>
                        <td>c6</td>
                        <td>HTTP (REST)</td>
                        <td>API Gateway</td>
                        <td>Cart API</td>
                    </tr>
                    <tr>
                        <td>c7</td>
                        <td>TCP (PostgreSQL driver)</td>
                        <td>Auth Service</td>
                        <td>Auth Database</td>
                    </tr>
                    <tr>
                        <td>c8</td>
                        <td>TCP (PostgreSQL driver)</td>
                        <td>Products API</td>
                        <td>Products Database</td>
                    </tr>
                    <tr>
                        <td>c9</td>
                        <td>TCP (MongoDB driver)</td>
                        <td>Cart API</td>
                        <td>Cart Database</td>
                    </tr>
                    <tr>
                        <td>c10</td>
                        <td>HTTPS/HTTP (Testing)</td>
                        <td>K6 Load Testing</td>
                        <td>Load Balancer</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Layered (Tier & Layer) View</h3>
                <p>A structured view showing the system's layered architecture and responsibilities.</p>
            </section>

            <section>
                <img src="layered-diagram.png" alt="Layered Architecture" class="architecture-diagram"
                    style="max-width: 50%;">
            </section>

            <section>
                <h3>Deployment Structure</h3>
                <p>Container orchestration pattern with Docker Compose, network segmentation, and load balancing for
                    high availability.</p>
            </section>

            <section>
                <img src="deployment-diagram.png" alt="Deployment Diagram" class="architecture-diagram"
                    style="max-width: 75%;">
            </section>

            <section>
                <h3>Decomposition Structure</h3>
                <p>A modular breakdown of system functionalities and their relationships.</p>
            </section>

            <section>
                <img src="decomposition.png" alt="Decomposition View" class="architecture-diagram">
            </section>

            <section>
                <img src="decomposition-diagram.png" alt="Functionalities vs Modules" class="architecture-diagram"
                style="max-width: 110%;">
            </section>

            <!-- Quality Properties -->
            <section>
                <h3>4. Quality Properties</h3>
                <p>Critical security and performance scenarios demonstrating system quality attributes.</p>
            </section>

            <section>
                <h3>Security Scenarios - Man in the Middle Attack</h3>
                <p>Protection against data interception through SSL/TLS encryption.</p>
            </section>

            <section>
                <img src="ssl.png" alt="SSL Protection" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>An attempt to intercept and read HTTP traffic between a client and the API Gateway.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An external attacker with access to the network path.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The communication channel between the client and the Load Balancer/API Gateway, secured with
                            TLS/SSL.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>A user is accessing the application from an untrusted public network.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The system enforces HTTPS-only communication. All data in transit is encrypted via TLS,
                            rendering any intercepted traffic unreadable to the attacker.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>Data confidentiality and integrity are preserved. The percentage of non-encrypted
                            connections should be 0%. Attempts to connect via HTTP are automatically rejected or
                            upgraded.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Security Scenarios - API Gateway Bypass</h3>
                <p>Prevention of direct microservice access through reverse proxy pattern.</p>
            </section>

            <section>
                <img src="reverse-proxy.png" alt="Reverse Proxy" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A crafted HTTP request is sent directly to the internal IP or hostname of a backend
                            microservice.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An external attacker or a compromised, non-critical external-facing service.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The API Gateway, which serves as the single entry point, and the network configuration that
                            isolates backend services.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production. Backend services are running in a private network, inaccessible from the public
                            internet.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The request fails because the private network is not exposed. The API Gateway is the only
                            component listening for external traffic, and it validates, authenticates, and sanitizes all
                            requests before forwarding them.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The attack surface is minimized by exposing only one entry point. The number of directly
                            accessible internal service endpoints from an external source is zero.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Security Scenarios - Network Segmentation</h3>
                <p>Isolation of critical components through network segmentation.</p>
            </section>

            <section>
                <img src="networks.png" alt="Network Segmentation" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A connection attempt is made from the compromised frontend container to the auth-db
                            container on its internal port (5432).</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An attacker who has gained remote code execution within the frontend container.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The Docker network configuration in docker-compose.yml, which defines two distinct networks:
                            public for external-facing services and private (with internal: true) for the backend and
                            databases.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production Docker deployment. The frontend container is connected only to the public
                            network, while the auth-db is exclusively on the private network.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The connection attempt from frontend to auth-db is blocked at the Docker network layer.
                            Because the containers do not share a common network and the private network is isolated, no
                            route exists between them.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>Lateral movement from the presentation tier to the data tier is prevented. The number of
                            unauthorized network paths between the public and private networks is zero.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Security Scenarios - Event Sourcing</h3>
                <p>Audit trail for critical data modifications.</p>
            </section>

            <section>
                <img src="event-sourcing.png" alt="Event Sourcing" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>Price of a high-value product is changed to a very low amount and later restored.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>Administrator with a legitimate account (no sign of compromise).</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>products-api service and products-db database.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production, normal business operations.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The system must immutably log every price change, including user, previous value, new value,
                            and timestamp.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>Ability to generate a complete change history; prove that the price changed from X to Y and
                            then from Y to X, with no possibility of tampering.</td>
                    </tr>
                </table>
            </section>

            <!-- Performance Scenarios -->
            <section>
                <h3>Performance Scenarios - Replication</h3>
                <p>Handling API Gateway instance failures through replication.</p>
            </section>

            <section>
                <img src="replication.png" alt="Replication" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>The primary API Gateway instance fails, and the system needs to ensure uninterrupted
                            service.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>A hardware failure or a software bug in the primary instance.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The API Gateway service, its configuration, and the load balancer's health check.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production. High availability is a critical requirement.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The system automatically detects the failure, marks the primary instance as unhealthy, and
                            routes traffic to a healthy secondary instance. The load balancer continuously monitors the
                            health of all API Gateway instances.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>Zero downtime for the API Gateway service. The percentage of failed requests to the API
                            Gateway should be minimal.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Performance Scenarios - Load Balancer</h3>
                <p>Managing increased concurrent users through load balancing.</p>
            </section>

            <section>
                <img src="load-balancer.png" alt="Load Balancer" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A sudden surge in traffic due to a marketing campaign or a popular product launch.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>External users accessing the application simultaneously.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The load balancer, its configuration, and the API Gateway's ability to handle concurrent
                            requests.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production. Scalability is a key requirement.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The load balancer distributes incoming requests across multiple API Gateway instances,
                            ensuring that no single instance is overwhelmed. It also manages session persistence and
                            sticky sessions if necessary.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The average response time for API Gateway requests remains stable, and no requests are
                            dropped or timed out.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Performance Scenarios - DOS Protection</h3>
                <p>Protection against denial of service attacks through rate limiting.</p>
            </section>

            <section>
                <img src="dos.png" alt="DOS Protection" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A malicious actor attempts to flood the API Gateway with a large number of requests,
                            exceeding its capacity.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An external attacker using automated tools or a botnet.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The API Gateway's rate limiting configuration, its ability to detect and block suspicious
                            requests, and the load balancer's ability to route legitimate traffic.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production. Availability and reliability are paramount.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The API Gateway and load balancer work together to block the overwhelming requests. The rate
                            limiter prevents the system from being overwhelmed by legitimate traffic, while the load
                            balancer ensures that the remaining requests are distributed evenly.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The system remains responsive and available, with minimal impact on user experience.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Performance Scenarios - Database Bottleneck</h3>
                <p>Managing database bottlenecks through Command Query Responsibility Segregation.</p>
            </section>

            <section>
                <img src="cqrs.png" alt="CQRS" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A high-volume read operation (e.g., fetching product details) is performed on the
                            products-db database.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>A user browsing the product catalog.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The products-api service and products-db database, configured for read-heavy workloads.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production. Scalability and performance are critical.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The read operation is routed to a dedicated read replica, which handles the majority of read
                            requests. The primary database handles write operations and complex queries.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>Fast response times for read operations, with minimal impact on write performance.</td>
                    </tr>
                </table>
            </section>

            <!-- Reliability Scenarios -->
            <section>
                <h3>5. Reliability Scenarios</h3>
                <p>Patterns and strategies ensuring system reliability and availability.</p>
            </section>

            <section>
                <h3>Replication Pattern</h3>
                <p>By default, GKE does not do "synchronous replication" of its nodes, but manages the node pools as
                    Compute Engine's Managed Instance Groups (MIGs) and maintains the desired state using an
                    eventual-consistent model.</p>
            </section>

            <section>
                <h3>Active Redundancy (Hot Spare) Pattern</h3>
                <p>Hot spare implementation for immediate failover capability.</p>
            </section>

            <section>
                <img src="hot-spare.png" alt="Hot Spare" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>The primary pod/node serving live traffic fails its liveness probe due to a hardware or
                            software fault.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An internal system event (e.g., node failure, pod crash).</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The Kubernetes Deployment with multiple replicas, a Service object for load balancing, and
                            liveness/readiness probes.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>A GKE cluster under normal operation. Replicas are running in a "hot" state, actively
                            processing data in parallel.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>Kubernetes detects the failed probe and immediately stops sending traffic to the failed pod.
                            The Service automatically reroutes new requests to one of the healthy "hot spare" pods,
                            which already has the latest state. Kubernetes then initiates the process of replacing the
                            failed pod.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The failover is transparent to the client. The time to detect failure and reroute traffic is
                            under 500ms. There is zero data loss since the spare was already synchronized.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Passive Redundancy (Warm Spare) Pattern</h3>
                <p>Warm spare implementation for cost-effective backup capability.</p>
            </section>

            <section>
                <img src="warm-spare.png" alt="Warm Spare" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>An external monitoring system detects that the primary service is completely unavailable
                            (e.g., all primary pods are failing).</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>A major failure in the primary service's node pool or a critical bug affecting all primary
                            replicas.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>A separate Kubernetes Deployment for the "warm spare" replica, node taints/tolerations to
                            keep it isolated, and an operational runbook or automated script to trigger the promotion.
                        </td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production. The primary service is handling all traffic, while the warm spare is running but
                            not receiving production requests.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>An operator or an automated system is alerted. The promotion process is initiated: the
                            NoSchedule taint is removed from the standby node pool, or the Service selector is updated
                            to include the warm spare. The spare begins receiving traffic.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The Recovery Time Objective (RTO) is met (e.g., service is restored in under 2 minutes).
                            Data loss is minimal to none, as the warm spare was synchronizing state.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Service Discovery Pattern</h3>
                <p>In GKE's VPC-native networking, each node automatically receives an alias IP range from the secondary
                    subnet and each pod is assigned an IP from that block. When autoscaling adds new nodes, the control
                    plane reserves a fresh alias IP range, updates the network routes, and pods can be scheduled
                    immediately with new IPs.</p>
            </section>

            <section>
                <img src="service-discovery.png" alt="Service Discovery" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>The API Gateway needs to send a request to the Products service and uses its logical name,
                            http://products-api, to establish a connection.</td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An internal application component (API Gateway) making a routine service-to-service call.
                        </td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The Kubernetes internal DNS service (CoreDNS), which maintains mappings between service
                            names and their corresponding ClusterIPs.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>A running GKE cluster where services are defined via Kubernetes Service objects.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The API Gateway's DNS resolver queries CoreDNS. CoreDNS resolves the name products-api to
                            its stable ClusterIP. Kubernetes then uses iptables or IPVS to forward the request to one of
                            the healthy backend pods for the service.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The service name is successfully and correctly resolved to an IP address. DNS lookup latency
                            is negligible (e.g., <10ms). The connection to the service is established successfully.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Cluster Pattern</h3>
                <p>Coordinated service management for high availability.</p>
            </section>

            <section>
                <img src="cluster-scenario.png" alt="Cluster Scenario" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A Compute Engine VM acting as a GKE node becomes unresponsive and fails its health checks.
                        </td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>An underlying hardware failure, OS-level corruption, or other critical issue within the VM.
                        </td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The GKE node pool, which is backed by a Compute Engine Managed Instance Group (MIG)
                            configured with auto-healing policies.</td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>A production GKE cluster.</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The MIG's health checker detects the unhealthy node. It automatically triggers the
                            auto-healing process: the faulty VM is terminated, and a new, identical VM is created to
                            replace it. The new node joins the GKE cluster, and Kubernetes begins scheduling pods onto
                            it.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The cluster's capacity is automatically restored without any manual intervention. The time
                            to provision and register the new node is within the expected range (typically a few
                            minutes). Workload disruption is minimized as Kubernetes reschedules pods that were on the
                            failed node.</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Transaction Pattern</h3>
                <p>Ensuring data consistency across distributed operations.</p>
            </section>

            <section>
                <img src="transaction.png" alt="Transaction" class="architecture-diagram">
            </section>

            <section>
                <table class="data-table">
                    <tr>
                        <th>Part</th>
                        <th>Detail</th>
                    </tr>
                    <tr>
                        <td>Stimulus</td>
                        <td>A user is completing a checkout. The system successfully deducts an item from the
                            products-api inventory, but the subsequent call to the payment processing service fails.
                        </td>
                    </tr>
                    <tr>
                        <td>Source of stimulus</td>
                        <td>A failure in a downstream service (payment processor) or a network timeout.</td>
                    </tr>
                    <tr>
                        <td>Artifact</td>
                        <td>The cart-api checkout logic, which orchestrates calls to multiple services (products-api,
                            payment service). It must include error handling and the logic for the compensating action.
                        </td>
                    </tr>
                    <tr>
                        <td>Environment</td>
                        <td>Production, during a multi-step, distributed transaction (Saga).</td>
                    </tr>
                    <tr>
                        <td>Response</td>
                        <td>The cart-api, upon detecting the payment failure, invokes a compensating transaction. It
                            sends a specific request to the products-api (e.g., POST /api/products/{id}/add-stock) to
                            add the previously deducted item back into inventory, effectively reversing the initial
                            operation.</td>
                    </tr>
                    <tr>
                        <td>Response metric</td>
                        <td>The system's data is restored to a consistent state. The product inventory is corrected. The
                            user is notified of the payment failure, but the system does not remain in an inconsistent
                            state (e.g., item sold but no payment received).</td>
                    </tr>
                </table>
            </section>

            <!-- Performance Analysis -->
            <section>
                <h3>14. Performance Analysis</h3>
                <p>Comprehensive analysis of system performance under various conditions.</p>
            </section>

            <section>
                <h3>Test Environment Configuration</h3>
                <table class="data-table">
                    <tr>
                        <th>Component</th>
                        <th>Specification</th>
                    </tr>
                    <tr>
                        <td>CPU</td>
                        <td>Apple M4 (10 cores)</td>
                    </tr>
                    <tr>
                        <td>RAM</td>
                        <td>24 GB</td>
                    </tr>
                    <tr>
                        <td>Storage</td>
                        <td>512 GB SSD</td>
                    </tr>
                    <tr>
                        <td>Network</td>
                        <td>60 Mbps bandwidth</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>Performance Results</h3>
                <table class="data-table">
                    <tr>
                        <th>Metric</th>
                        <th>Overall Result</th>
                        <th>Read Scenario</th>
                        <th>Creation Scenario</th>
                    </tr>
                    <tr>
                        <td>Total Requests</td>
                        <td>18,563</td>
                        <td>14,303</td>
                        <td>4,260</td>
                    </tr>
                    <tr>
                        <td>Failed Requests</td>
                        <td>0.67% (126)</td>
                        <td>0.55% (80)</td>
                        <td>1.08% (46)</td>
                    </tr>
                    <tr>
                        <td>P95 Duration</td>
                        <td>87.79 ms</td>
                        <td>77.26 ms</td>
                        <td>118.03 ms</td>
                    </tr>
                </table>
            </section>

            <section>
                <h3>System Behavior Analysis</h3>
                <img src="knee_point_graph.png" alt="Knee Point Analysis" class="architecture-diagram">
            </section>

            <!-- Thank You -->
            <section>
                <h3>Thank You</h3>
                <div class="team-member">
                    <p>Team 1a - Software Architecture Project</p>
                    <p class="tiny-text">Xamir Ernesto Rojas Gamboa | Juan Sebastian Medina Pinto | Juan Manuel Pérez
                        Ordoñez</p>
                </div>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            transition: 'slide',
            transitionSpeed: 'default',
            backgroundTransition: 'fade',
            controls: true,
            progress: true,
            center: true,
            touch: true,
            loop: false,
            rtl: false,
            fragments: true,
            embedded: false,
            help: true,
            pause: true,
            showNotes: false,
            autoPlayMedia: null,
            preloadIframes: null,
            autoAnimate: true,
            autoAnimateMatcher: null,
            autoAnimateEasing: 'ease',
            autoAnimateDuration: 1.0,
            autoAnimateUnmatched: true,
            autoAnimateStyles: [
                'opacity',
                'color',
                'background-color',
                'padding',
                'font-size',
                'line-height',
                'letter-spacing',
                'border-width',
                'border-color',
                'border-radius',
                'outline',
                'outline-offset'
            ],
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>